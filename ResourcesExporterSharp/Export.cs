using System.Xml;
using System.Xml.Serialization;

partial class RessourcesExporterSharp
{
    static IEnumerable<string> GetNextResourcePath(string path)
    {
        foreach (var file in Directory.GetFiles(path))
        {
            if (file.EndsWith(".resx"))
            {
                yield return file;
            }
        }
        foreach (var folder in Directory.GetDirectories(path))
        {
            foreach (var f in GetNextResourcePath(folder))
            {
                yield return f;
            }
        }
    }

    public static void Export()
    {
        if (File.Exists("Output.resx"))
        {
            File.Delete("Output.resx");
        }

        Console.WriteLine("Please enter path to main folder containing all the resx");
        string? path = Console.ReadLine();

        if (string.IsNullOrEmpty(path) || !Directory.Exists(path))
        {
            Console.WriteLine("Invalid argument, exiting...");
            return;
        }

        var writer = XmlWriter.Create("Output.resx");
        // TODO: This isn't kept so better put it somewhere better
        writer.WriteComment("Auto-generated by ResourcesExporterSharp, under MIT license by Christian Chaux, more information at https://github.com/Xwilarg/ResourcesExporterSharp/blob/master/LICENSE");

        List<(Resource Resource, string Path)> resources = new();
        XmlSerializer xml = new(typeof(Resource));

        // Get all resources file and get their content if they are valid
        foreach (var file in GetNextResourcePath(path))
        {
            Console.Write($"Found resource file at {file}... ");
            using var stream = new FileStream(file, FileMode.Open, FileAccess.Read);
            var tmp = xml.Deserialize(stream);
            Resource res = (Resource)tmp!;

            if (res == null || res.Data == null || !res.Data.Any())
            {
                Console.WriteLine("No data, skipping");
                continue;
            }
            if (res.Data.All(x => !string.IsNullOrEmpty(x.Type) || !string.IsNullOrEmpty(x.Mimetype)))
            {
                Console.WriteLine("Data contains no string, skipping");
                continue;
            }
            Console.WriteLine($"OK, {res.Data.Length} elements");

            resources.Add((res, file));
        }

        if (!resources.Any())
        {
            Console.WriteLine("Fatal Error: No resource found");
            return;
        }

        // We write the path in the "Other" section as binary to find back the original paths
        var data = resources.SelectMany(x => x.Resource.Data).ToList();
        using var ms = new MemoryStream();
        using var binWriter = new BinaryWriter(ms);
        binWriter.Write(resources.Count);
        foreach (var res in resources)
        {
            binWriter.Write(res.Resource.Data.Length);
            binWriter.Write(res.Path);
        }

        data.Add(new()
        {
            Name = "METADATA",
            Value = Convert.ToBase64String(ms.ToArray()),
            Comment = "DO NOT MODIFY",
            Mimetype = Constants.MetadataMimeType
        });

        var output = new Resource()
        {
            Data = data.ToArray(),
            Resheaders = resources[0].Resource.Resheaders
        };
        xml.Serialize(writer, output);
        writer.Flush();
        writer.Close();

        Console.WriteLine("OK");
    }
}